# GC是什么？ #
GC的英文全称是:Gabage Collection，翻译成中文就是垃圾回收的意思。在一个对象不再被程序引用时，它所占用的堆空间就可以回收，以便于分配给新的对象使用。

那我们在了解回收机制要先了解的知识有哪些

##我们先说三个英语
###(Minor GC) vs (Major GC) vs (Full GC)
- Minor GC代表着新生
- Major GC是清理旧老的
- Full GC 是清理整个堆空间—包括新生和旧老


##JVM和DVM的不同点

###1、Dalvik 和标准 Java 虚拟机(JVM)的首要差别

Dalvik 基于寄存器，而 JVM 基于栈。基于寄存器的虚拟机对于更大的程序来说，在它们编译的时候，花费的时间更短。

###2、Dalvik 和 Java 字节码的区别

Dalvik执行.dex格式的字节码，而JVM执行.class格式的字节码。android程序编译完之后生产.class文件，还有通过aapt工具生成的R.class等，然后dx工具会把.class文件处理成.dex文件，最终资源文件和.dex文件等打包成.apk文件。

###3、Dalvik和Java运行环境的区别

Dalvik主要是完成对象生命周期管理，堆栈管理，线程管理，安全和异常管理，以及垃圾回收等等重要功能。 
Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。

步骤：

（1，JVM是怎么分配内存的，,2，识别哪些内存是垃圾需要回收，,3，最后才是用什么方式回收。）

 栈的内存管理是顺序分配的，而且定长，不存在内存回收问题；而堆 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题；

   一，内存分配：

Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于
内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了。

java一般内存申请有两种：静态内存和动态内存

。
很容易理解，编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量；动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。

二，垃圾的回收方法及思路：

垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。怎么检测出垃圾？一般有以下几种方法：





（检测垃圾的算法）
引用计数法：

给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。
好了，问题来了，如果我有两个对象A和B，互相引用，除此之外，没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是我们说的垃圾对象。但是互相引用，计数不为0，导致无法回收，所以还有另一种方法：


可达性分析算法：

以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象
本地方法中引用的对象等。
总之，JVM在做垃圾回收的时候，会检查堆中的所有对象是否会被这些根集对象引用，不能够被引用的对象就会被垃圾收集器回收。一般回收算法也有如下几种：





（处理垃圾的算法）


1.标记-清除（Mark-sweep）


算法和名字一样，分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的。
不足：效率低；标记清除之后会产生大量碎片。


2.复制（Copying）


此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。 


3.标记-整理（Mark-Compact）
此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。 


4.分代收集算法(当今最常用的方法)
这是当前商业虚拟机常用的垃圾收集算法。分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
为什么要运用分代垃圾回收策略？在java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同所具有的功能不同所以也有着不一样的生命周期，有的对象生命周期较长，比如Http请求中的Session对象，线程，Socket连接等；有的对象生命周期较短，比如String对象，由于其不变类的特性，有的在使用一次后即可回收。试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式。
如何划分？


将对象按其生命周期的不同划分成：


年轻代(Young Generation)、
年老代(Old Generation)、
持久代(Permanent Generation)。

其中持久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代。这里有个比喻很形象
“假设你是一个普通的 Java 对象，你出生在 Eden 区，在 Eden 区有许多和你差不多的小兄弟、小姐妹，可以把 Eden 区当成幼儿园，在这个幼儿园里大家玩了很长时间。Eden 区不能无休止地放你们在里面，所以当年纪稍大，你就要被送到学校去上学，这里假设从小学到高中都称为 Survivor 区。开始的时候你在 Survivor 区里面划分出来的的“From”区，读到高年级了，就进了 Survivor 区的“To”区，中间由于学习成绩不稳定，还经常来回折腾。直到你 18 岁的时候，高中毕业了，该去社会上闯闯了。于是你就去了年老代，年老代里面人也很多。在年老代里，你生活了 20 年 (每次 GC 加一岁)，最后寿终正寝，被 GC 回收。有一点没有提，你在年老代遇到了一个同学，他的名字叫爱德华 (慕光之城里的帅哥吸血鬼)，他以及他的家族永远不会死，那么他们就生活在永生代。”






新生代：



是所有新对象产生的地方。

年轻代被分为3个部分——Enden区和两个Survivor区（From和to）

当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区（假设为from区）。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区（假设为to区）。这样在一段时间内，总会有一个空的survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。

需要注意，Survivor的两个区是对称的，没先后关系，from和to是相对的。




旧老代：



在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中，可以说他们都是久经沙场而不亡的一代，都是生命周期较长的对象。对于年老代和永久代，就不能再采用像年轻代中那样搬移腾挪的回收算法，因为那些对于这些回收战场上的老兵来说是小儿科。这时候MajsorGC会清理些老年代垃圾，通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。
持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响。 
  

垃圾收集器
垃圾收集算法是内存回收的方法论，而实现这些方法论的则是垃圾收集器。这里就不详细描述了。



GC中对象的六种可触及状态
   1.强可触及：对象可以从根结点不通过任何引用对象搜索到
   2.软可触及：对象不是强可触及的，但是可以从根结点开始通过一个或多个（未被清除的）软引用对象触及
   3.弱可触及：对象既不是强可触及也不是软可触及的，但是从根结点开始

   4.可复活的：对象既不是强可触及、软可触及，也不是弱可触及，但是仍然可能通过执行某些终结方法复活到这几种状态之一
   5.影子可触及：不上以上任何可触及状态，也不能通过终结方法复活，并且它可以从根结点开始通过一个或多个影子引用对象触及（影子引用不会被垃圾收集器清除，由程序明确地清除）
   6不可触及：就是已经准备回收的状态